# 第二周学习内容

## Java Socket编程

其实与其说是讲socket，不如说更多的是讲优化。老师上课讲的用Java Socket API搭建简单的HTTP server 01那个例子，不知为何我本机上执行失败了，没有返回预期内容。

## IO模型

从最简单的串行执行，到复杂的IO模型，其实还是为了提升程序的执行效率，更多的利用现有的硬件资源。从早期的单机10K，到单机100K，并发能力的不断提升跟IO模型息息相关

### 通信模型

同步、异步：通信相关的模式

阻塞、非阻塞：线程处理模式

### 阻塞式IO

<img src="https://cdn.jsdelivr.net/gh/N1ckeyQu/picbed@main/img/202110091407785.png" alt="image-20211009140700722" style="zoom: 50%;" />

用户线程发起read请求，内核不会立即返回数据，而是要等待数据到达后，将数据从内核copy到用户内存，将copy的数据返回给用户线程才算是read完成。秦老师写的http server 01就使用了这样一种模型

内核等待数据到达的这段时间内，其实我们的CPU是什么事情都没有做的，因为用户线程处于阻塞状态。有没有一种办法利用这段空闲的时间，让用户线程继续做其它事情，提高CPU的利用率呢？

注意：数据到达的过程，大体上是网卡接收网络传来的数据，再将网卡收到的数据复制到内核空间中

### 非阻塞式IO

<img src="https://cdn.jsdelivr.net/gh/N1ckeyQu/picbed@main/img/202110091425912.png" alt="未命名文件 (2)" style="zoom:50%;" />

全程non-blocking IO，非阻塞式IO。如图所示，它将IO拆分成了两个阶段，第一个阶段内核不再傻傻等待数据返回，不管数据是否到达，只要用户线程发起read请求，就立即返回结果。用户线程通过轮询方式获取数据的到达状态。确认数据到达后，再通过系统调用，将数据从内核空间的缓冲区复制到用户空间缓冲区（linux的内存分为两部分，一部分供内核操作，一部分供用户操作），最终返回给用户线程

虽然整个流程还是同步而非异步，但是程序的执行效率提升了，因为第一阶段时，用户线程不再阻塞，CPU可以分心做别的事情，这就为我们后面的多路IO复用模型埋下伏笔

注意：第二个阶段仍然是阻塞的

### 多路复用IO模型（事件驱动模型）

<img src="https://cdn.jsdelivr.net/gh/N1ckeyQu/picbed@main/img/202110091457091.png" alt="image-20211009145709067" style="zoom:50%;" />

对于非阻塞式IO模型，每个用户线程都负责到底。比如用户线程A需要进行IO相关操作，那么用户线程A就需要进行轮询来查询数据的准备状态，一旦socket可读，就发送read请求，将数据从内核态copy到用户态，拿到数据，流程结束。简而言之，谁要进行IO操作，谁负责到底

就比如餐厅的侍者在门口接待客人，将客人带到相应的座位，然后进厨房做饭，端出来给客人。多路IO复用模型优化的就是这个问题，它引入了Reactor——注册事件处理器，reactor线程专门负责线程轮询这一部分的相关操作（select/poll），它可以负责多个socket，数据准备好了之后，reactor会通知相应的用户线程，然后用户线程发送read请求，拿到IO数据。其实跟软件开发的基本原则很相似——单一职责原则。对于轮询查看数据状态这种相同的工作，专门抽出来一个线程来处理，实现解耦，用户线程从此告别IO模型的第一阶段

注意：

- 多路复用IO模型有两个地方是阻塞的，一个是线程轮询这里使用的select和poll指令，另一个是第二阶段数据copy的过程
- 面试中经常问到的NIO其实就是这种多路复用IO模型

#### select/poll的缺点

在Unix/类Unix系统中有一个很重要的思想：一切皆文件，或者叫fd——file descriptor，文件描述符

- 每次调用select指令，都会把fd集合从用户态copy到内核态，然后在内核中遍历传入的fd集合，因此当fd集合较大时，执行select指令的开销也会很大
- select支持的fd数量太小，默认是1024

基于这些缺点，Linux 2.6内核正式引入epoll，可用于替代select/poll，它的特点如下：

- 内核态于用户态共享同一块内存（netty中所谓的零拷贝就基于此）
- 支持回调（拒绝轮询，提高资源利用率）
- fd没有限制，可以支撑10w连接

### 信号驱动IO

![image-20211009155257721](https://cdn.jsdelivr.net/gh/N1ckeyQu/picbed@main/img/202110091552745.png)

信号驱动IO相较于多路复用IO，更进一步降低了用户线程操作的复杂度，因为它已经连Reactor都不需要了！
用户线程向内核发起read请求，内核会返回一个信号handler给用户线程。等到数据到达后，内核直接给对应的handler发信号，告知用户线程数据已经准备好了，然后用户线程再发送read请求获取IO数据。当然，要实现信号驱动IO模型，需要操作系统的支持

## etty

如果我们需要用Java语言开发网络应用，netty框架是一个优秀的选择，它是一款异步、事件驱动、基于NIO的高性能的网络应用开发框架。事实上netty已经算是行业的标准了，只要是网络相关的需求要实现，我们都可以使用netty

netty主要分为三部分：core、传输服务、协议支持

### 基本概念

- channel

  通道，Java NIO中的基础概念，代表一个打开的连接，可以执行读取/写入IO操作。Netty对Channel中的所有IO操作都是非阻塞的

- channelFuture

  netty封装的一个接口，可以将回调方法传给channelFuture，在操作完成时自动执行传入的回调方法

- event & handler

  netty基于事件驱动，事件和处理器可以关联到入站和出站数据流

- encoder & decoder

  处理网络IO时需要进行序列化和反序列化，转换Java对象与字节流